C++<head>

#include<iostream>
#include<cstring>
#include<cmath>
#include<stdlib.h>
#define For(i,j,k) for(i=j;i<=k;i++)
#define FFor(i,j,k) for(i=j;i>=k;i--)
using namespace std;

</head>

Import C++:质数
bool isPn(int inp){
    if((inp%2==0&&inp!=2)||inp==1)return 0;
    int i;bool asd=true;
    int d=sqrt(inp);
    for(i=3;i<=d;i+=2){
        if(inp%i==0){
            asd=false;
            return asd;
        }
    }
    return asd;
}

Import C++ 高精正整数比较
int Hcmp(char a[],char b[]){
	int al=strlen(a),bl=strlen(b);
	if(al>bl)return 1;
	else if(bl>al)return -1;
	else return strcmp(a,b);
}

Import C++ 高精正整数加
string Hsum(char a[],char b[]){    
	int i;string h="";int ab[max(strlen(a),strlen(b))];    
	For(i,0,max(strlen(a),strlen(b))-1)ab[i]=0;    
	FFor(i,max(strlen(a),strlen(b))-1,0){        
		if(strlen(a)>strlen(b))ab[i]+=a[i]+(strlen(a)-i<=strlen(b)?b[i-(strlen(a)-strlen(b))]:48)-96;        
		else ab[i]+=(strlen(b)-strlen(a)<=i?a[i+(strlen(a)-strlen(b))]:48)+b[i]-96;        
		if(i!=0){ab[i-1]+=ab[i]/10;ab[i]%=10;}
	}
	h+=ab[0]/10+48;h+=ab[0]%10+48;    
	For(i,1,max(strlen(a),strlen(b))-1)h+=ab[i]+48;    
	return h;
}

void HIZsum(int *a,int *b,int len1,int len2,int *back){
	for(int i=0;i<=max(len1,len2);i++)back[i]+=a[i]+b[i];
	for(int i=0;i<=max(len1,len2);i++){back[i+1]+=back[i]/10;back[i]%=10;}
}//精简版，取代Hsum//逆序输入输出

Import C++ 高精正整数减
string Hsub(char a[],char b[]){ 
	int i;string h="";bool first=false;int ab[max(strlen(a),strlen(b))];
	char c[max(strlen(a),strlen(b))],d[max(strlen(a),strlen(b))];
	if(Hcmp(a,b)==1){strcpy(c,a);strcpy(d,b);}
	else if(Hcmp(a,b)==0)return "0";
	else {strcpy(d,a);strcpy(c,b);h+="-";}
	FFor(i,max(strlen(c),strlen(d))-1,0)ab[i]=0;
	FFor(i,max(strlen(c),strlen(d))-1,0){
		ab[i]+=(c[i]-((strlen(c)-strlen(d)<=i)?d[i-(strlen(c)-strlen(d))]:48));
		if(ab[i]<0){ab[i]+=10;ab[i-1]--;}
	}
	For(i,0,max(strlen(c),strlen(d))-1)if(ab[i]!=0||first){h+=ab[i]+48;first=true;}
	return h;
}

Import C++高精度正整数乘/高精正小数乘

string Hmul(char a[],char b[]){ 
	if(a[0]=='0'||b[0]=='0')return "0"; 
	int i,j,u,ab[strlen(a)+strlen(b)];
	bool first=false;string h=""; 
	For(i,0,strlen(a)+strlen(b))ab[i]=0; 
	FFor(i,strlen(a)-1,0){  
		FFor(j,strlen(b)-1,0){   
			ab[i+j+1]+=(a[i]-48)*(b[j]-48);   
			ab[i+j]+=ab[i+j+1]/10;ab[i+j+1]%=10;  
		} 
	} 
	For(u,0,strlen(a)+strlen(b)-1)if(ab[u]!=0||first){h+=(ab[u]+48);first=true;} 
return h;
}

H高精，I整，Z正整。
void HIZmul(int *a,int *b,int len1,int len2,int *back){
	for(int i=0;i<=len1-1;i++)for(int j=0;j<=len2-1;j++)back[i+j]+=a[i]*b[j];
	for(int i=0;i<=len1+len2-1;i++){back[i+1]+=back[i]/10;back[i]%=10;}
}//精简版，取代Hmul//逆序输入输出

string HDmul(char *a,char *b){
	int i,j,u;int lena=strlen(a),lenb=strlen(b);string h="";
	For(i,1,lena)if(a[lena-i]=='.')break;
	For(j,1,lenb)if(b[lenb-j]=='.')break;
	if(i==strlen(a))i=0;if(j==strlen(b))j=0;
	if(i+j==0)return Hmul(a,b);
	if(i>j){
		while(j<i){
			j++;
			b[strlen(b)]=48;
		}
	}else if(j>i){
		while(j>i){
			i++;
			a[strlen(a)]=48;
		}
	}
	For(u,strlen(a)-i,strlen(a)-2)a[u]=a[u+1];a[u]=0;
	For(u,strlen(b)-j,strlen(b)-2)b[u]=b[u+1];b[u]=0;
	h=Hmul(a,b);
	h.insert(h.size()-i-j+2,".");
	return h;
}

Import C++ 高精正整数除正Long Long
string LHdiv(char a[],long long b){
	int i,ab[strlen(a)];long long BC=0;bool first=false;string h;
	For(i,0,strlen(a)-1)ab[i]=0;
	For(i,0,strlen(a)-1){
		BC*=10;BC+=a[i]-48;
		ab[i]=BC/b;BC%=b;
	}
	For(i,0,strlen(a)-1)if(ab[i]!=0||first){h+=(ab[i]+48);first=true;}
	return h;
}
#include<bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

#include<bits/stdc++.h>using namespace std;int mod;
union line_tree{ struct node{  long long lazy[2],num;int l,r; }tree[400000]; void push_up(int place)tree[place].num=(tree[place>>1|1].num+tree[place>>1].num)%mod; void push_down(){   } void build(int place,int down,int up){  if(up==down)return;   }};
int main(){ int a,b;cin>>a>>b>>mod; }












